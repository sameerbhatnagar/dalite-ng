(function (exports) {
'use strict';

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var LoadingSpinner = /*#__PURE__*/function (_HTMLElement) {
  _inherits(LoadingSpinner, _HTMLElement);

  function LoadingSpinner() {
    var _this;

    _classCallCheck(this, LoadingSpinner);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingSpinner).call(this));

    var shadow = _this.attachShadow({
      mode: "open"
    });

    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("spinner");
    svg.setAttribute("viewBox", "0 0 100 100");
    shadow.appendChild(svg);
    var ring = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    ring.classList.add("spinner__ring");
    ring.setAttribute("cx", "50");
    ring.setAttribute("cy", "50");
    ring.setAttribute("r", "47");
    ring.setAttribute("fill", "transparent");
    ring.setAttribute("stroke-width", "6");
    svg.appendChild(ring);
    var segment = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    segment.classList.add("spinner__segment");
    segment.setAttribute("cx", "50");
    segment.setAttribute("cy", "50");
    segment.setAttribute("r", "47");
    segment.setAttribute("fill", "transparent");
    segment.setAttribute("stroke-width", "6");
    segment.setAttribute("stroke-dasharray", "200");
    segment.setAttribute("stroke-dashoffset", "0");
    svg.appendChild(segment);
    var style = document.createElement("style");
    style.textContent = "\n.spinner {\n  animation: 1.75s spin linear infinite;\n}\n\n.spinner__ring {\n  stroke: var(--spinner-ring-stroke, #d3d3d3);\n}\n\n.spinner__segment {\n  stroke: var(--spinner-segment-stroke, #f2f2f2);\n}\n\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}";

    var nonce = _this.getAttribute("nonce") || _this.nonce;

    if (nonce) {
      style.setAttribute("nonce", nonce);
    }

    shadow.appendChild(style);
    return _this;
  }

  return LoadingSpinner;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));

function toggleFoldable(event) {
  var foldable = event.currentTarget.parentNode;

  if (foldable.classList.contains("foldable__unfolded")) {
    foldable.classList.remove("foldable__unfolded");
    foldable.querySelector(".foldable--body").style.overflow = "hidden";
  } else {
    foldable.classList.add("foldable__unfolded");
    setTimeout(function () {
      foldable.querySelector(".foldable--body").style.overflow = "auto";
    }, 300);
  }
}

function handleDragStart(event) {
  var elem = event.currentTarget;
  elem.classList.add("draggable--dragging");
  event.dataTransfer.effectAllowed = "move";
  event.dataTransfer.setData("title", elem.getAttribute("data-draggable-name"));
  window.currentDraggedName = elem.getAttribute("data-draggable-name");
}

function handleDragEnd(event) {
  var elem = event.currentTarget;
  elem.classList.remove("draggable--dragging");
  Array.from(elem.parentNode.getElementsByClassName("draggable")).map(function (x) {
    return x.classList.remove("draggable--over");
  });
}

function handleDragEnter(event) {
  var elem = event.currentTarget;
  var container = elem.parentNode;
  var title = event.dataTransfer.getData("title") || window.currentDraggedName;
  var oldElem = Array.from(container.children).filter(function (x) {
    return x.getAttribute("data-draggable-name") == title;
  })[0];
  var oldIdx = Array.from(container.children).indexOf(oldElem);
  var idx = Array.from(container.children).indexOf(elem);

  if (idx > oldIdx) {
    container.insertBefore(oldElem, elem.nextSibling);
  } else if (idx < oldIdx) {
    container.insertBefore(oldElem, elem);
  }
}

function handleDragLeave(event) {
  var elem = event.currentTarget;
  elem.classList.remove("draggable--over");
}

function handleDragOver(event) {
  if (event.preventDefault) {
    event.preventDefault();
  }

  event.dataTransfer.dropEffect = "move";
  return false;
}

function handleDrop(event) {
  if (event.preventDefault) {
    event.preventDefault();
  }

  if (event.stopPropagation) {
    event.stopPropagation();
  }

  return false;
}

function addEventListeners() {
  Array.from(document.getElementsByClassName("foldable--title")).map(function (x) {
    return x.addEventListener("click", function (e) {
      return toggleFoldable(e);
    });
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("dragstart", function (e) {
      return handleDragStart(e);
    }, false);
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("dragend", function (e) {
      return handleDragEnd(e);
    }, false);
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("dragenter", function (e) {
      return handleDragEnter(e);
    }, false);
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("dragleave", function (e) {
      return handleDragLeave(e);
    }, false);
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("dragover", function (e) {
      return handleDragOver(e);
    }, false);
  });
  Array.from(document.getElementsByClassName("draggable")).map(function (x) {
    return x.addEventListener("drop", function (e) {
      return handleDrop(e);
    }, false);
  });
}

if (!customElements.get("loading-spinner")) {
  customElements.define("loading-spinner", LoadingSpinner);
}

exports.addEventListeners = addEventListeners;

}((this.custom_elements = this.custom_elements || {})));
//# sourceMappingURL=custom_elements.min.js.map
