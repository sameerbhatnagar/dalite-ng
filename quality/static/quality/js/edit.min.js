(function (exports) {
'use strict';

"use strict";

function getCsrfToken() {
  return document.getElementsByName("csrfmiddlewaretoken")[0].getAttribute("value");
}
function buildReq(data, method) {
  if (method.toLowerCase() === "get") {
    return {
      method: method.toUpperCase(),
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCsrfToken()
      }
    };
  } else if (method.toLowerCase() === "post") {
    var body = data ? JSON.stringify(data) : "";
    return {
      method: method.toUpperCase(),
      body: body,
      headers: {
        "Content-Type": "application/json",
        "X-CSRFToken": getCsrfToken()
      }
    };
  } else {
    throw Error("Method ".concat(method, " not implemented yet."));
  }
}

function _AwaitValue(value) {
  this.wrapped = value;
}

function _AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen.return !== "function") {
    this.return = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

_AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

_AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
};

_AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};

"use strict";

function clear(node) {
  while (node.hasChildNodes()) {
    // $FlowFixMe
    node.removeChild(node.lastChild);
  }

  return node;
}

/*********/

/* model */

/*********/

var model;

function initModel(data) {
  model = {
    quality: {
      pk: data.quality.pk,
      qualityType: data.quality.quality_type
    },
    next: data.next,
    available: data.available.map(function (c) {
      return {
        name: c.name,
        fullName: c.full_name,
        description: c.description
      };
    }),
    criterions: data.criterions,
    urls: {
      addCriterion: data.urls.add_criterion,
      updateCriterion: data.urls.update_criterion,
      removeCriterion: data.urls.remove_criterion
    }
  };
}
/**********/

/* update */

/**********/


function updateCriterionOption(event, option, criterion) {
  var type = option.getAttribute("data-type");
  var name = option.getAttribute("name");
  var value;

  if (type === "CommaSepField" || type === "ManyToManyField") {
    option.querySelector(".comma-sep-input--input").setCustomValidity("");

    if (event.key === "Enter" || event.key === "," || event.key === " ") {
      if (value === " " || value === ",") {
        value = "";
      }

      value = option.querySelector(".comma-sep-input--input").value;

      if (!value) {
        event.preventDefault();
        return;
      }

      if (criterion[name].allowed) {
        if (!criterion[name].allowed.includes(value)) {
          toggleCriterionOptionError(option.querySelector(".comma-sep-input--input"), "".concat(value, " isn't an accepted language. Options are ").concat(criterion[name].allowed.slice(0, criterion[name].allowed.length - 1).join(", "), " and ").concat(criterion[name].allowed[criterion[name].allowed.length - 1], "."));
          option.querySelector(".comma-sep-input--input").value = "";
          event.preventDefault();
          return;
        }
      }
    } else if (event.key === "Backspace") {
      value = option.querySelector(".comma-sep-input--input").value;

      if (value) {
        return;
      }
    } else {
      return;
    }
  } else if (type === "PositiveIntegerField" || type === "ProbabilityField" || type === "FloatField" || type === "IntegerField") {
    option.setCustomValidity("");
    value = option.value;

    if (value === "") {
      if (event.inputType === "insertText" && event.data === "-") {
        value = 0;
        option.value = 0;
      } else {
        return;
      }
    }

    if (type === "ProbabilityField") {
      if (value < 0) {
        value = 0;
        option.value = value;
      } else if (value > 1) {
        value = parseFloat("0." + value);
        option.value = value;
      } else if (value.toString().length > 4) {
        option.value = model.criterions.filter(function (c) {
          return c.name === criterion.name;
        })[0][name].value;
        return;
      } else if (model.criterions.filter(function (c) {
        return c.name === criterion.name;
      })[0][name].value == value) {
        if (value === "00") {
          option.value = "0";
        }

        return;
      }
    }
  } else if (type === "BooleanField") {
    option.setCustomValidity("");
    value = option.value === "false";
  } else {
    option.setCustomValidity("");
    value = option.value;
  }

  var data = {
    quality: model.quality.pk,
    criterion: criterion.name,
    field: name,
    value: value
  };
  var req = buildReq(data, "post");
  fetch(model.urls.updateCriterion, req).then(function (resp) {
    return resp.ok ? resp.json() : resp.text();
  }).then(function (data) {
    if (typeof data === "string") {
      toggleCriterionOptionError(err);
    } else {
      model.criterions = model.criterions.map(function (c) {
        return c.name === data.name ? data : c;
      });

      if (name === "weight") {
        criterionOptionView(type, data.weight, criterion, option);
      } else {
        criterionOptionView(type, data[name].value, criterion, option);
      }
    }
  }).catch(function (err) {
    return console.log(err);
  });
}

function addCriterion(criterion) {
  var data = {
    quality: model.quality.pk,
    criterion: criterion.name
  };
  var req = buildReq(data, "post");
  fetch(model.urls.addCriterion, req).then(function (resp) {
    return resp.json();
  }).then(function (json) {
    model.criterions.push(json);
    criterionsView();
    newCriterionsView();
    toggleShowAddCriterion();
  }).catch(function (err) {
    return console.log(err);
  });
}

function removeCriterion(criterion) {
  var data = {
    quality: model.quality.pk,
    criterion: criterion.name
  };
  var req = buildReq(data, "post");
  fetch(model.urls.removeCriterion, req).then(function (resp) {
    if (resp.ok) {
      model.criterions = model.criterions.filter(function (c) {
        return c.name != criterion.name;
      });
      criterionsView();
      newCriterionsView();
    }
  }).catch(function (err) {
    return console.log(err);
  });
}
/********/

/* view */

/********/


function view() {
  returnLinkView();
  criterionsView();
  newCriterionsView();
}

function returnLinkView() {
  var link = document.querySelector("#back-link");

  if (model.next) {
    link.href = model.next;

    if (model.quality.qualityType === "teacher") {
      link.textContent = "Back to account";
    } else {
      link.textContent = "Back to ".concat(model.quality.qualityType);
    }
  } else {
    link.parentNode.removeChild(link);
  }
}

function criterionsView() {
  var div = document.querySelector("#criterions");
  clear(div);
  model.criterions.forEach(function (criterion) {
    div.appendChild(criterionView(criterion));
  });
}

function criterionView(criterion) {
  var div = document.createElement("div");
  div.classList.add("criterion");
  div.classList.add("criterion__showing");
  div.name = criterion.name;
  var name = document.createElement("div");
  name.classList.add("criterion--name");
  name.textContent = criterion.full_name;
  name.title = criterion.description;
  name.addEventListener("click", function () {
    return toggleCriterionOptions(div);
  });
  div.appendChild(name);
  var remove = document.createElement("button");
  remove.classList.add("criterion--remove");
  remove.addEventListener("click", function (event) {
    removeCriterion(criterion);
    event.stopPropagation();
  });
  name.appendChild(remove);
  var icon = document.createElement("i");
  icon.classList.add("material-icons");
  icon.textContent = "close";
  remove.appendChild(icon);
  var options = document.createElement("div");
  options.classList.add("criterion--options");
  div.appendChild(options);
  var binaryThreshold = criterion.versions[criterion.version - 1].binary_threshold; // const versionLabel = document.createElement("label");
  // versionLabel.textContent = "Version:";
  // const version = document.createElement("select");
  // const versions = [document.createElement("option")];
  // versions[0].value = 0;
  // versions[0].textContent = "0 (latest)";
  // versions.forEach(v => {
  // version.appendChild(v);
  // });
  // options.appendChild(versionLabel);
  // options.appendChild(version);
  //

  var weightLabel = document.createElement("label");
  weightLabel.textContent = "Weight:";
  var weight = criterionOptionView("PositiveIntegerField", criterion.weight, criterion);
  weight.name = "weight";
  options.appendChild(weightLabel);
  options.appendChild(weight);
  var otherOptions = Object.keys(criterion).filter(function (o) {
    return !["description", "full_name", "is_beta", "name", "version", "versions", "weight"].includes(o);
  });
  otherOptions.forEach(function (o) {
    if (!binaryThreshold || o !== "threshold") {
      var option = criterion[o];
      var label = document.createElement("label");
      label.textContent = "".concat(option.full_name, ":");
      label.title = option.description;
      var input = criterionOptionView(option.type, option.value, criterion, null);
      input.setAttribute("name", option.name);
      options.appendChild(label);
      options.appendChild(input);
    }
  });
  return div;
}

function criterionOptionView(type, value, criterion) {
  var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var focus = !!input;

  if (type === "PositiveIntegerField") {
    if (!input) {
      input = document.createElement("input");
      input.setAttribute("data-type", type);
      input.type = "number";
      input.min = 0;
      input.addEventListener("input", function (event) {
        return updateCriterionOption(event, input, criterion);
      });
    }

    input.value = value;
    return input;
  } else if (type === "ProbabilityField") {
    if (!input) {
      input = document.createElement("input");
      input.setAttribute("data-type", type);
      input.type = "number";
      input.min = 0;
      input.max = 1;
      input.step = 0.01;
      input.addEventListener("input", function (event) {
        return updateCriterionOption(event, input, criterion);
      });

      if (focus) {
        input.focus();
      }
    }

    input.value = value;
    return input;
  } else if (type === "CommaSepField" || type === "ManyToManyField") {
    if (!input) {
      input = document.createElement("div");
      input.setAttribute("data-type", type);
      input.classList.add("comma-sep-input");
      input.type = "comma-sep";
    }

    clear(input);
    value.forEach(function (word) {
      var span = document.createElement("span");
      span.classList.add("comma-sep-input--word");
      span.textContent = word;
      input.appendChild(span);
    });
    var input_ = document.createElement("input");
    input_.classList.add("comma-sep-input--input");
    input_.type = "text";
    input_.addEventListener("keydown", function (event) {
      return updateCriterionOption(event, input, criterion);
    });
    input.appendChild(input_);

    if (focus) {
      input_.focus();
    }

    return input;
  } else if (type === "BooleanField") {
    if (!input) {
      input = document.createElement("div");
      input.setAttribute("data-type", type);
      input.classList.add("boolean-input");
      clear(input);

      var _input_ = document.createElement("input");

      _input_.classList.add("boolean-input--input");

      _input_.type = "checkbox";

      _input_.addEventListener("click", function (event) {
        return updateCriterionOption(event, input, criterion);
      });

      input.appendChild(_input_);
      var background = document.createElement("span");
      background.classList.add("boolean-input--background");
      input.appendChild(background);
      var mark = document.createElement("span");
      mark.classList.add("boolean-input--mark");
      input.appendChild(mark);

      if (focus) {
        _input_.focus();
      }
    }

    input.value = value;
    return input;
  }
}

function toggleCriterionOptions(criterion) {
  if (criterion.classList.contains("criterion__showing")) {
    criterion.classList.remove("criterion__showing");
  } else {
    criterion.classList.add("criterion__showing");
  }
}

function toggleCriterionOptionError(option, msg) {
  option.setCustomValidity(msg);
}

function newCriterionsView() {
  var button = document.querySelector(".add-criterion button");
  var available = model.available.filter(function (c) {
    return !model.criterions.map(function (cc) {
      return cc.name;
    }).includes(c.name);
  });

  if (available.length) {
    var ul = document.querySelector(".available-criterions ul");
    clear(ul);
    available.forEach(function (criterion) {
      ul.appendChild(newCriterionView(criterion));
    });
    button.disabled = false;
    button.title = "Add a new criterion";
  } else {
    button.disabled = true;
    button.title = "There are no new criterions to add";
  }
}

function newCriterionView(criterion) {
  var li = document.createElement("li");
  li.title = criterion.description;
  li.textContent = criterion.fullName;
  li.addEventListener("click", function () {
    return addCriterion(criterion);
  });
  return li;
}

function toggleShowAddCriterion() {
  var div = document.querySelector(".add-criterion");

  if (div.classList.contains("add-criterion__showing")) {
    div.classList.remove("add-criterion__showing");
  } else {
    if (model.available.length) {
      div.classList.add("add-criterion__showing");
    }
  }
}
/*************/

/* listeners */

/*************/


function initEventListeners() {
  initAddCriterionListeners();
}

function initAddCriterionListeners() {
  document.querySelector(".add-criterion button").addEventListener("click", toggleShowAddCriterion);
}
/********/

/* init */

/********/


function init(data) {
  initModel(data);
  view();
  initEventListeners();
}

"use strict";

exports.init = init;

}((this.edit = this.edit || {})));
//# sourceMappingURL=edit.min.js.map
